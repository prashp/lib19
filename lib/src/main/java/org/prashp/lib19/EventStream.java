/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.prashp.lib19;

import java.util.ArrayList;
import java.util.Comparator;

public class EventStream implements Runnable{ // FIXME - make this class extend Runnable

    SourceStream source;
    SinkStream sink;

    boolean stop = false;

    long duration;


    public EventStream(SourceStream source, SinkStream sink, long timeWindowMillis) {
        duration = timeWindowMillis;
        this.source = source;
        this.sink = sink;

    }

    /**
     * Sorts events in given stream by version in a given duration
     */
    public void process() {
        // FIXME - this method should start a new thread that handles the below logic
        Thread eventLogic = new Thread(new EventStream(source, sink, duration));
        eventLogic.setDaemon(true);
        eventLogic.start();


        //sorts by using version

        //writes sorted events to sink stream


    }

    public static void main(String[] args) throws Exception {
        Runnable sumanthRunnable = new Runnable() {
            @Override
            public void run() {
               log(">>>>>>>>> " + Thread.currentThread().getName());
            }
        };

        //sumanthRunnable.run();

        log("BEFORE new thread");
        Thread sumThread = new Thread(sumanthRunnable, "SUMANTH");
        sumThread.start();
        log("STARTED new thread, SLEEPING");

        Thread.sleep(5_000);
        log("DONE SLEEP");

    }

    private static void log(String str)
    {
        System.out.println(Thread.currentThread().getName() + " " + str);
    }

    public void stop() {
        this.stop = true;
    }

    @Override
    public void run() {

        log("Starting Run");
        //instantiate buffer; will be used to hold events
        ArrayList<Event> buffer = new ArrayList<>();

        //use nanoTime to calculate how much time elapsed.
        long finish = (long) (System.nanoTime() + duration * Math.pow(10,9));
        while(!stop)
        {
            log("Adding to buffer");
            while(finish >= System.nanoTime()) {
                buffer.add(source.getEvent());
            }
            log("Done adding to buffer; sorting now");

            buffer.sort(Comparator.comparingLong(Event::getVersion));

            for (Event e : buffer)
            {
                sink.writeEvent(e);
            }
            buffer.clear();

        }
    }


    public static class Event {
        final long version;
        final long timestamp;
        final Object payload;

        public Event(long version, long timestamp, Object payload) {
            this.version = version;
            this.timestamp = timestamp;
            this.payload = payload;
        }

        public long getVersion() {
            return version;
        }

        public long getTimestamp() {
            return timestamp;
        }

        public Object getPayload() {
            return payload;
        }


    }

}


interface SourceStream {
    EventStream.Event getEvent();
}

interface SinkStream {
    void writeEvent(EventStream.Event e);
}

